import { IpcTypeFlag, } from "./common.js";
import { send, sendInternal, sendStream, sendStreamInternal } from "./send.js";
import { Failure } from "./failure.js";
import { system } from "@minecraft/server";
import { MAX_MESSAGE_LENGTH, MAX_ROUTER_UID_LENGTH } from "./constants.js";
/**
 * An IPC router. This must be constructed to send and recieve IPC events.
 */
export class Router {
    uid;
    internalIsValid = true;
    /**
     * key = stream ID
     * value = cached content from previous events
     */
    pendingStreams = new Map();
    listeners = new Map();
    /**
     * total number of listener uids generated by this router, used to create unique listener IDs for invoke responses.
     */
    listenerUidsGenerated = 0;
    /**
     * total number of steam uids generated by this router, used to create unique stream IDs.
     */
    streamUidsGenerated = 0;
    /**
     * @throws Throws if the UID is invalid.
     */
    constructor(
    /**
     * A **unique** ID for this router. If another router has the same ID, it may cause problems.
     * Must be less characters than {@link MAX_ROUTER_UID_LENGTH}.
     */
    uid) {
        this.uid = uid;
        if (!uid || uid.length > MAX_ROUTER_UID_LENGTH) {
            throw new Error(`Router UID must be at least one character and less than ${MAX_ROUTER_UID_LENGTH.toString()} characters.`);
        }
        system.afterEvents.scriptEventReceive.subscribe(this.onScriptEventRecieved);
    }
    /**
     * Has this object been destroyed?
     */
    get isValid() {
        return this.internalIsValid;
    }
    /**
     * Unsubscribe from all Minecraft events and mark this object as invalid.
     */
    destroy() {
        system.afterEvents.scriptEventReceive.unsubscribe(this.onScriptEventRecieved);
        this.internalIsValid = false;
    }
    /**
     * Registers an IPC listener.
     * @param event The listener ID.
     * @param callback The callback.
     * @throws Throws if another listener is registered with the same ID.
     */
    registerListener(event, callback) {
        if (this.listeners.has(event)) {
            throw new Error(`Failed to register listener '${event}'. A listener with this ID has already been registered.`);
        }
        if (!event.includes(":") || event.split(":")[1].startsWith("_")) {
            throw new Error(`Failed to register listener '${event}'. Listener IDs must have a namespace and cannot start with an underscore after the namespace.`);
        }
        this.listeners.set(event, callback);
    }
    /**
     * Removes a listener for an event.
     * @param event The event ID.
     * @returns Returns a boolean indicating whether the listener was removed or not.
     */
    removeListener(event) {
        return this.listeners.delete(event);
    }
    /**
     * Send a one-way IPC event.
     * @throws Throws if the message is too long.
     */
    send(options) {
        send(options);
    }
    /**
     * Stream a one-way IPC event. The payload has no max length, since it is streamed.
     */
    sendStream(options) {
        return sendStream(options, this.generateStreamUid());
    }
    /**
     * Send or stream a one-way IPC event. If the payload is greater than the max length then it will be streamed.
     */
    async sendAuto(options) {
        const serialized = JSON.stringify(options.payload);
        if (serialized.length > MAX_MESSAGE_LENGTH) {
            return sendStreamInternal(IpcTypeFlag.SendStream, options.event, serialized, this.generateStreamUid(), options.force);
        }
        sendInternal(IpcTypeFlag.Send, {
            ...options,
            payload: serialized,
        });
    }
    /**
     * Send a two-way IPC event.
     * @returns Returns whatever the listener returns.
     * @throws Throws if a response is not recieved within 20 game ticks.
     * @throws Throws if the message is too long.
     */
    invoke(options) {
        return this.invokeInternal({
            ...options,
            payload: JSON.stringify(options.payload),
        }, this.generateListenerUid());
    }
    /**
     * Stream a two-way IPC event. The payload has no max length since it is streamed.
     * @returns Returns whatever the listener returns.
     * @throws Throws if a response is not recieved within 20 game ticks (after the entire payload has been streamed).
     * @throws Throws if the message is too long.
     */
    invokeStream(options) {
        return this.invokeStreamInternal({
            ...options,
            payload: JSON.stringify(options.payload),
        }, this.generateListenerUid(), this.generateStreamUid());
    }
    /**
     * Send or stream a two-way IPC event. If the payload is greater than the max length then it will be streamed.
     * @returns Returns whatever the target listener returns.
     * @throws Throws if a response is not recieved within 20 game ticks (after the entire payload has been streamed).
     */
    invokeAuto(options) {
        const serialized = JSON.stringify(options.payload);
        const responseListenerId = this.generateListenerUid();
        const actualPayloadLength = 
        // additional character for the space between the response listener ID and the payload
        serialized.length + responseListenerId.length + 1;
        if (actualPayloadLength > MAX_MESSAGE_LENGTH) {
            return this.invokeStreamInternal({ ...options, payload: serialized }, responseListenerId, this.generateStreamUid());
        }
        return this.invokeInternal({ ...options, payload: serialized }, responseListenerId);
    }
    setListener(event, callback) {
        this.listeners.set(event, callback);
    }
    invokeInternal(options, responseListenerId) {
        return new Promise((resolve, reject) => {
            const timeoutId = system.runTimeout(() => {
                this.removeListener(responseListenerId);
                reject(new Error(`Invoke '${options.event}' timed out.`));
            }, 80);
            this.setListener(responseListenerId, (payload) => {
                this.removeListener(responseListenerId);
                system.clearRun(timeoutId);
                if (payload instanceof Failure && options.throwFailures) {
                    reject(payload);
                }
                else {
                    resolve(payload);
                }
                return null;
            });
            sendInternal(IpcTypeFlag.Invoke, {
                ...options,
                payload: `${responseListenerId} ${options.payload}`,
            });
        });
    }
    invokeStreamInternal(options, responseListenerId, streamId) {
        let timeoutId;
        return new Promise((resolve, reject) => {
            this.setListener(responseListenerId, (payload) => {
                this.removeListener(responseListenerId);
                if (timeoutId !== undefined) {
                    system.clearRun(timeoutId);
                }
                if (payload instanceof Failure && options.throwFailures) {
                    reject(payload);
                }
                else {
                    resolve(payload);
                }
                return null;
            });
            void sendStreamInternal(IpcTypeFlag.InvokeStream, options.event, `${responseListenerId} ${options.payload}`, streamId, options.force).finally(() => {
                timeoutId = system.runTimeout(() => {
                    this.removeListener(responseListenerId);
                    reject(new Error(`Invoke '${options.event}' timed out.`));
                }, 20);
            });
        });
    }
    generateListenerUid() {
        return `${this.uid}:__${(this.listenerUidsGenerated++).toString(36)}`;
    }
    generateStreamUid() {
        return this.uid + (this.streamUidsGenerated++).toString(36);
    }
    parseRawPayload(rawPayload) {
        const payload = JSON.parse(rawPayload);
        if (typeof payload === "object" &&
            payload !== null &&
            "__IPCFAILURE__" in payload) {
            return new Failure(payload.__IPCFAILURE__);
        }
        return payload;
    }
    async invokeListener(listener, responseEvent, rawPayload) {
        const payload = this.parseRawPayload(rawPayload);
        let response = null;
        let err;
        try {
            response = await listener(payload);
        }
        catch (e) {
            err = e;
        }
        if (response instanceof Failure) {
            response = {
                __IPCFAILURE__: response.message,
            };
        }
        void this.sendAuto({
            event: responseEvent,
            payload: response,
        });
        if (err) {
            console.warn(err);
        }
    }
    async callListener(listener, rawPayload) {
        const payload = this.parseRawPayload(rawPayload);
        try {
            const result = await listener(payload);
            if (result instanceof Failure) {
                console.warn(result);
            }
        }
        catch (err) {
            console.warn(err);
        }
    }
    routeEvent(id, rawMsg) {
        const listener = this.listeners.get(id);
        if (!listener)
            return;
        // the first character should be the ipc type flag
        const ipcTypeFlag = rawMsg[0];
        // skip the ipc type flag
        const message = rawMsg.slice(1);
        switch (ipcTypeFlag) {
            case IpcTypeFlag.Send:
                void this.callListener(listener, message);
                break;
            case IpcTypeFlag.Invoke: {
                const [responseEvent, payload] = message.split(/ (.*)/);
                void this.invokeListener(listener, responseEvent, payload);
                break;
            }
            case IpcTypeFlag.InvokeStream:
            case IpcTypeFlag.SendStream: {
                const [id, afterId] = message.split(/ (.*)/);
                const [isEndRaw, content] = afterId.split(/ (.*)/);
                const isEnd = isEndRaw === "t";
                const cachedContent = this.pendingStreams.get(id) ?? "";
                const fullContent = cachedContent + content;
                if (!isEnd) {
                    this.pendingStreams.set(id, fullContent);
                    break;
                }
                this.pendingStreams.delete(id);
                if (ipcTypeFlag === IpcTypeFlag.InvokeStream) {
                    const [responseEvent, payload] = fullContent.split(/ (.*)/);
                    void this.invokeListener(listener, responseEvent, payload);
                    break;
                }
                void this.callListener(listener, fullContent);
                break;
            }
        }
    }
    onScriptEventRecieved = (e) => {
        this.routeEvent(e.id, e.message);
    };
}
